/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author cunbidun
 */

#include <bits/stdc++.h>
#include <algorithm>
#include <chrono>
#include <iostream>
#include <random>
#include <vector>
#include <utility>
#include <tuple>

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef pair<ii, int> iii;
typedef vector<ii> vii;
/**
 * Matrix of Char MC(Row, Col, atoz?, AtoZ?, 1to9?, Custom)
 * Forest: F(NumNode, NumEdge, StartAt)
 * Graph: G(NumNode, NumEdge, StartAt, isConnected?, isMultiEdge?, iSelfLoop?)
 * Weighted Graph: WG(NumNode, NumEdge, StartAt, isConnected?, isMultiEdge?, iSelfLoop?, minW, maxW)
 */
namespace impl {
    using Random = std::mt19937;
}

inline impl::Random &randomEngine() {
    static std::random_device device;
    static impl::Random engine(device());
    return engine;
}

inline int randomInteger(int to) {
    std::uniform_int_distribution<int> d(0, to);
    return d(randomEngine());
}

inline int randInt(int from, int to) {
    return from + randomInteger(to - from);
}

inline vi randArr(int l, int min, int max) {
    vi a;
    for (int i = 1; i <= l; i++)
        a.pb(randInt(min, max));
    return a;
}

inline vector<pair<int, int>> randArrPair(int l, bool less, int min, int max) {
    vector<ii> a;
    for (int i = 1; i <= l; i++) {
        int first = randInt(min, max);
        int second = randInt(min, max);
        if (less && first > second) {
            int t = first;
            first = second;
            second = t;
        }
        a.pb(mp(first, second));
    }
    return a;
}

inline vector<vi> rand2DArr(int r, int c, int min, int max) {
    vector<vi> a(r, vi());
    for (int i = 0; i < r; i++)
        a[i] = randArr(c, min, max);
    return a;
}

inline string randString(int l, string sample) {
    string toReturn = "";
    int size = sz(sample);
    while (l--) {
        int tmp = randInt(0, size);

        toReturn += sample[randInt(0, size - 1)];
    }
    return toReturn;
}

inline string randString(int l, bool lower, bool upper, bool number) {
    string sample = "";
    string lowList = "abcdefghijklmnopqrstuvwxyz";
    string upList = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    string numList = "0123456789";
    if (lower) sample += lowList;
    if (upper) sample += upList;
    if (number) sample += numList;
    return randString(l, sample);
}

inline vii randTree(int n) {
    vii toReturn;
    for (int i = 2; i <= n; i++)
        toReturn.push_back({i, randInt(1, i - 1)});
    return toReturn;
}

inline vector<iii> randTree(int n, int min, int max) {
    vii tree = randTree(n);
    vector<iii> toReturn;
    for (ii p:tree) {
        toReturn.push_back(mp(mp(p.first, p.second), randInt(min, max)));
    }
    return toReturn;
}

inline vii randDAG(int v, int e) {
    set<string> set;
    vii DAG;
    for (int i = 0; i < e; i++) {
        int tmp1 = -1;
        int tmp2 = -1;
        while (tmp1 == tmp2 || set.find(to_string(tmp1) + to_string(tmp2)) != set.end()) {
            int pos = randInt(1, v - 1);
            tmp1 = pos;
            tmp2 = randInt(pos + 1, v);
        }
        DAG.pb(mp(tmp1, tmp2));
        set.insert(to_string(tmp1) + to_string(tmp2));
    }
    return DAG;
}

inline vector<iii> randDAG(int v, int e, int min, int max) {
    vii DAG = randDAG(v, e);
    vector<iii> toReturn;
    for (ii p:DAG) {
        toReturn.push_back(mp(mp(p.first, p.second), randInt(min, max)));
    }
    return toReturn;
}

inline string to_string(vii list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        ii p = list[i];
        res += to_string(p.first) + " " + to_string(p.second);
        if (i != sz(list) - 1) res += "\n";
    }
    return res;
}

inline string to_string(vector<iii> list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        iii p = list[i];
        res += to_string(p.first.first) + " " + to_string(p.first.second) + " " + to_string(p.second);
        if (i != sz(list) - 1) res += "\n";
    }
    return res;
}

inline string to_string(vi list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        res += to_string(list[i]) + " ";
    }
    return res;
}

inline string to_string(vector<vi> list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        res += to_string(list[i]) + " ";
        if (i != sz(list) - 1) res += "\n";
    }
    return res;
}

#define F first
#define S second
#define pb push_back
#define mp make_pair
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define watch(x) out << (#x) << " = " << (x) << endl
#define rf(i, a, b) for(int (i) = (a); (i) <= (b); (i)++)
#define rb(i, b, a) for(int (i) = (b); (i) >= (a); (i)--)

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef pair<ii, int> iii;
typedef vector<ii> vii;

const int N = 2e5 + 10;
const int INF = 2e9;

class Task615D {
public:

    int mul(int x, int y, int MOD) { return (int) ((1LL * x * y) % MOD); }

    int pow(int x, ll p, int MOD) {
        if (p == 0) return 1;
        int t = pow(x, p / 2, MOD);
        if ((p & 1) == 1)
            return mul(mul(t, t, MOD), x, MOD);
        return mul(t, t, MOD);
    }

    void solve(istream &in, ostream &out) {
        int MOD = 1e9 + 7;
        int n;
        in >> n;
        vi cnt(N);
        rf(i, 1, n) {
            int x;
            in >> x;
            cnt[x]++;
        }
        int ans = 1;
        int d = 1;
        rf(i, 1, N - 1) if (cnt[i] != 0) {
                int cur = pow(i, 1ll * cnt[i] * (cnt[i] + 1) / 2, MOD);
                ans = pow(ans, cnt[i] + 1, MOD);
                ans = mul(ans, pow(cur, d, MOD), MOD);
//                watch(i);
//                watch(cnt[i]);
//                watch(ans);
                d = mul(d, cnt[i] + 1, MOD - 1);
            }
        out << ans << "\n";
    }
};

class TestCase {
public:
    static constexpr int numTest = 0;
    static constexpr bool haveAns = true;


    static void generateTest(ostream &test) {
    }

    static void solve(istream &in, ostream &out) {
    }
};

class Checker {
public:
    static constexpr double arg = 0.0;

    static bool check(istream &in, istream &out) {
    }
};



int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    Task615D solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    out << fixed << setprecision(10);
    solver.solve(in, out);
    return 0;
}