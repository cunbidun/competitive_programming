/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author cunbidun
 */

#include <bits/stdc++.h>
#include <algorithm>
#include <chrono>
#include <iostream>
#include <random>
#include <vector>
#include <utility>
#include <tuple>

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef pair<ii, int> iii;
typedef vector<ii> vii;
/**
 * Matrix of Char MC(Row, Col, atoz?, AtoZ?, 1to9?, Custom)
 * Forest: F(NumNode, NumEdge, StartAt)
 * Graph: G(NumNode, NumEdge, StartAt, isConnected?, isMultiEdge?, iSelfLoop?)
 * Weighted Graph: WG(NumNode, NumEdge, StartAt, isConnected?, isMultiEdge?, iSelfLoop?, minW, maxW)
 */
namespace impl {
    using Random = std::mt19937;
}

inline impl::Random &randomEngine() {
    static std::random_device device;
    static impl::Random engine(device());
    return engine;
}

inline int randomInteger(int to) {
    std::uniform_int_distribution<int> d(0, to);
    return d(randomEngine());
}

inline int randInt(int from, int to) {
    return from + randomInteger(to - from);
}

inline vi randArr(int l, int min, int max) {
    vi a;
    for (int i = 1; i <= l; i++)
        a.pb(randInt(min, max));
    return a;
}

inline vector<pair<int, int>> randArrPair(int l, bool less, int min, int max) {
    vector<ii> a;
    for (int i = 1; i <= l; i++) {
        int first = randInt(min, max);
        int second = randInt(min, max);
        if (less && first > second) {
            int t = first;
            first = second;
            second = t;
        }
        a.pb(mp(first, second));
    }
    return a;
}

inline vector<vi> rand2DArr(int r, int c, int min, int max) {
    vector<vi> a(r, vi());
    for (int i = 0; i < r; i++)
        a[i] = randArr(c, min, max);
    return a;
}

inline string randString(int l, string sample) {
    string toReturn = "";
    int size = sz(sample);
    while (l--) {
        int tmp = randInt(0, size);

        toReturn += sample[randInt(0, size - 1)];
    }
    return toReturn;
}

inline string randString(int l, bool lower, bool upper, bool number) {
    string sample = "";
    string lowList = "abcdefghijklmnopqrstuvwxyz";
    string upList = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    string numList = "0123456789";
    if (lower) sample += lowList;
    if (upper) sample += upList;
    if (number) sample += numList;
    return randString(l, sample);
}

inline vii randTree(int n) {
    vii toReturn;
    for (int i = 2; i <= n; i++)
        toReturn.push_back({i, randInt(1, i - 1)});
    return toReturn;
}

inline vector<iii> randTree(int n, int min, int max) {
    vii tree = randTree(n);
    vector<iii> toReturn;
    for (ii p:tree) {
        toReturn.push_back(mp(mp(p.first, p.second), randInt(min, max)));
    }
    return toReturn;
}

inline vii randDAG(int v, int e) {
    set<string> set;
    vii DAG;
    for (int i = 0; i < e; i++) {
        int tmp1 = -1;
        int tmp2 = -1;
        while (tmp1 == tmp2 || set.find(to_string(tmp1) + to_string(tmp2)) != set.end()) {
            int pos = randInt(1, v - 1);
            tmp1 = pos;
            tmp2 = randInt(pos + 1, v);
        }
        DAG.pb(mp(tmp1, tmp2));
        set.insert(to_string(tmp1) + to_string(tmp2));
    }
    return DAG;
}

inline vector<iii> randDAG(int v, int e, int min, int max) {
    vii DAG = randDAG(v, e);
    vector<iii> toReturn;
    for (ii p:DAG) {
        toReturn.push_back(mp(mp(p.first, p.second), randInt(min, max)));
    }
    return toReturn;
}

inline string to_string(vii list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        ii p = list[i];
        res += to_string(p.first) + " " + to_string(p.second);
        if (i != sz(list) - 1) res += "\n";
    }
    return res;
}

inline string to_string(vector<iii> list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        iii p = list[i];
        res += to_string(p.first.first) + " " + to_string(p.first.second) + " " + to_string(p.second);
        if (i != sz(list) - 1) res += "\n";
    }
    return res;
}

inline string to_string(vi list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        res += to_string(list[i]) + " ";
    }
    return res;
}

inline string to_string(vector<vi> list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        res += to_string(list[i]) + " ";
        if (i != sz(list) - 1) res += "\n";
    }
    return res;
}

#define F first
#define S second
#define pb push_back
#define mp make_pair
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define watch(x) out << (#x) << " = " << (x) << endl
#define rf(i, a, b) for(int (i) = (a); (i) <= (b); (i)++)
#define rb(i, b, a) for(int (i) = (b); (i) >= (a); (i)--)

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef pair<ii, int> iii;
typedef vector<ii> vii;

const int N = 3e4 + 10;
const int MOD = 1e9 + 7;
const int INF = 1e9;

class Task821D {
public:
    int n, m, k;
    set<ii> s;
    map<ii, int> pos;
    vii a[N];
    vi d;

    void dijkstra(int s) {
        priority_queue<ii, vector<ii>, greater<ii>> pq;
        d[s] = 0;
        pq.push({0, s});
        while (!pq.empty()) {
            int u = pq.top().second;
            int du = pq.top().first;
            pq.pop();
            if (du > d[u]) continue;
            for (ii p : a[u]) {
                int v = p.second;
                int uv = p.first;
                if (d[v] > du + uv) {
                    d[v] = du + uv;
                    pq.push({d[v], v});
                }
            }
        }
    }

    bool isValid(int i, int j) {
        return 1 <= i && i <= n && 1 <= j && j <= m;
    }

    void solve(istream &in, ostream &out) {
        d.assign(N, INF);
        int dx[] = {0, 0, 1, -1};
        int dy[] = {1, -1, 0, 0};
        in >> n >> m >> k;
        int p = 0;
        rf(i, 1, k) {
            int x, y;
            in >> x >> y;
            s.insert({x, y});
            pos[{x, y}] = ++p;
        }
        if (s.find({n, m}) == s.end()) pos[{n, m}] = ++p;

        rf(i, 1, n)pos[{i, 0}] = ++p;
        rf(i, 1, m)pos[{0, i}] = ++p;

        a[pos[{n, 0}]].pb({0, pos[{n, m}]});
        a[pos[{0, m}]].pb({0, pos[{n, m}]});

        for (auto it : s) {
            int x = it.F;
            int y = it.S;
            if (x > 1) {
                a[pos[{x, y}]].pb({1, pos[{x - 1, 0}]});
                a[pos[{x - 1, 0}]].pb({0, pos[{x, y}]});
            }
            if (y > 1) {
                a[pos[{x, y}]].pb({1, pos[{0, y - 1}]});
                a[pos[{0, y - 1}]].pb({0, pos[{x, y}]});
            }
            if (x < n) {
                a[pos[{x, y}]].pb({1, pos[{x + 1, 0}]});
                a[pos[{x + 1, 0}]].pb({0, pos[{x, y}]});

            }
            if (y < m) {
                a[pos[{x, y}]].pb({1, pos[{0, y + 1}]});
                a[pos[{0, y + 1}]].pb({0, pos[{x, y}]});

            }
            a[pos[{x, y}]].pb({1, pos[{0, y}]});
            a[pos[{x, y}]].pb({1, pos[{x, 0}]});
            a[pos[{x, 0}]].pb({0, pos[{x, y}]});
            a[pos[{0, y}]].pb({0, pos[{x, y}]});
            rf(i, 0, 3) if (isValid(x + dx[i], y + dy[i])) {
                    if (s.find({x + dx[i], y + dy[i]}) != s.end()) {
                        a[pos[{x, y}]].pb({0, pos[{x + dx[i], y + dy[i]}]});
                    }
                }
        }
////        for (ii p: a[1]) {
////            out << p.F << " " << p.S << "\n";
////        }
//        for (ii p: a[12]) {
//            out << p.F << " " << p.S << "\n";
//        }
        dijkstra(pos[{1, 1}]);
//        rf(i, 1, 15)out << "d[" << i << "]=" << d[i] << "\n";

        if ((d[pos[{n, m}]] == INF)) out << "-1";
        else out << d[pos[{n, m}]];
        out << "\n";
    }
};

class TestCase {
public:
    static constexpr int numTest = 0;
    static constexpr bool haveAns = false;

    static void generateTest(ostream &test) {
    }

    static void solve(istream &in, ostream &out) {
    }
};

class Checker {
public:
    static constexpr double arg = 0.0;

    static bool check(istream &in, istream &out) {
    }
};



int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
   	Task821D solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    out << fixed << setprecision(10);
	solver.solve(in, out);
	return 0;
}