/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author cunbidun
 */

#include <bits/stdc++.h>
#include <algorithm>
#include <chrono>
#include <iostream>
#include <random>
#include <vector>
#include <utility>
#include <tuple>

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef pair<ii, int> iii;
typedef vector<ii> vii;
/**
 * Matrix of Char MC(Row, Col, atoz?, AtoZ?, 1to9?, Custom)
 * Forest: F(NumNode, NumEdge, StartAt)
 * Graph: G(NumNode, NumEdge, StartAt, isConnected?, isMultiEdge?, iSelfLoop?)
 * Weighted Graph: WG(NumNode, NumEdge, StartAt, isConnected?, isMultiEdge?, iSelfLoop?, minW, maxW)
 */
namespace impl {
    using Random = std::mt19937;
}

inline impl::Random &randomEngine() {
    static std::random_device device;
    static impl::Random engine(device());
    return engine;
}

inline int randomInteger(int to) {
    std::uniform_int_distribution<int> d(0, to);
    return d(randomEngine());
}

inline int randInt(int from, int to) {
    return from + randomInteger(to - from);
}

inline vi randArr(int l, int min, int max) {
    vi a;
    for (int i = 1; i <= l; i++)
        a.pb(randInt(min, max));
    return a;
}

inline vector<pair<int, int>> randArrPair(int l, bool less, int min, int max) {
    vector<ii> a;
    for (int i = 1; i <= l; i++) {
        int first = randInt(min, max);
        int second = randInt(min, max);
        if (less && first > second) {
            int t = first;
            first = second;
            second = t;
        }
        a.pb(mp(first, second));
    }
    return a;
}

inline vector<vi> rand2DArr(int r, int c, int min, int max) {
    vector<vi> a(r, vi());
    for (int i = 0; i < r; i++)
        a[i] = randArr(c, min, max);
    return a;
}

inline string randString(int l, string sample) {
    string toReturn = "";
    int size = sz(sample);
    while (l--) {
        int tmp = randInt(0, size);

        toReturn += sample[randInt(0, size - 1)];
    }
    return toReturn;
}

inline string randString(int l, bool lower, bool upper, bool number) {
    string sample = "";
    string lowList = "abcdefghijklmnopqrstuvwxyz";
    string upList = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    string numList = "0123456789";
    if (lower) sample += lowList;
    if (upper) sample += upList;
    if (number) sample += numList;
    return randString(l, sample);
}

inline vii randTree(int n) {
    vii toReturn;
    for (int i = 2; i <= n; i++)
        toReturn.push_back({i, randInt(1, i - 1)});
    return toReturn;
}

inline vector<iii> randTree(int n, int min, int max) {
    vii tree = randTree(n);
    vector<iii> toReturn;
    for (ii p:tree) {
        toReturn.push_back(mp(mp(p.first, p.second), randInt(min, max)));
    }
    return toReturn;
}

inline vii randDAG(int v, int e) {
    set<string> set;
    vii DAG;
    for (int i = 0; i < e; i++) {
        int tmp1 = -1;
        int tmp2 = -1;
        while (tmp1 == tmp2 || set.find(to_string(tmp1) + to_string(tmp2)) != set.end()) {
            int pos = randInt(1, v - 1);
            tmp1 = pos;
            tmp2 = randInt(pos + 1, v);
        }
        DAG.pb(mp(tmp1, tmp2));
        set.insert(to_string(tmp1) + to_string(tmp2));
    }
    return DAG;
}

inline vector<iii> randDAG(int v, int e, int min, int max) {
    vii DAG = randDAG(v, e);
    vector<iii> toReturn;
    for (ii p:DAG) {
        toReturn.push_back(mp(mp(p.first, p.second), randInt(min, max)));
    }
    return toReturn;
}

inline string to_string(vii list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        ii p = list[i];
        res += to_string(p.first) + " " + to_string(p.second);
        if (i != sz(list) - 1) res += "\n";
    }
    return res;
}

inline string to_string(vector<iii> list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        iii p = list[i];
        res += to_string(p.first.first) + " " + to_string(p.first.second) + " " + to_string(p.second);
        if (i != sz(list) - 1) res += "\n";
    }
    return res;
}

inline string to_string(vi list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        res += to_string(list[i]) + " ";
    }
    return res;
}

inline string to_string(vector<vi> list) {
    string res = "";
    for (int i = 0; i < sz(list); i++) {
        res += to_string(list[i]) + " ";
        if (i != sz(list) - 1) res += "\n";
    }
    return res;
}

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair
#define rf(i, a, b) for(int (i) = (a); (i) <= (b); (i)++)
#define rb(i, b, a) for(int (i) = (b); (i) >= (a); (i)--)
#define watch(x) cout << (#x) << " = " << (x) << endl

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef vector<ii> vii;

const int N = 1e5 + 1;

class Task443D {
public:
    void solve(istream &in, ostream &out) {
        int n;
        in >> n;
        vector<double> a;
        rf(i, 1, n) {
            double tmp;
            in >> tmp;
            a.push_back(tmp);
        }
        sort(all(a), greater<double>());
        double ans = 0;
        vector<double> b;
        for (double d: a) {
            b.pb(d);
            ans = max(ans, cal(b));
        }
        out << ans << '\n';
    }

    double cal(vector<double> &a) {
        double res = 0.0;
        for (int i = 0; i < sz(a); i++) {
            double cur = a[i];
            for (int j = 0; j < sz(a); j++)
                if (i != j) {
                    cur *= (1 - a[j]);
                }
            res += cur;
        }
        return res;
    }
};

class TestCase {
public:
    static constexpr bool printWAOnly = false;
    static constexpr int numTest = 0;
    static constexpr bool haveAns = true;

    static void generateTest(ostream &test) {
    }

    static void solve(istream &in, ostream &out) {
    }
};

class Checker {
public:
    static constexpr double arg = 1e-9;

    static bool check(istream &in, istream &out) {
    }
};



int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
   	Task443D solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    out << fixed << setprecision(10);
	solver.solve(in, out);
	return 0;
}