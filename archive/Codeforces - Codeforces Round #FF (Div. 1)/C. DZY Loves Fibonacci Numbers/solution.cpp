/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author cunbidun
 */

#include <bits/stdc++.h>

#define F first
#define S second
#define pb push_back
#define mp make_pair
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define watch(x) out << (#x) << " = " << (x) << endl
#define rf(i, a, b) for(int (i) = (a); (i) <= (b); (i)++)
#define rb(i, b, a) for(int (i) = (b); (i) >= (a); (i)--)

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef pair<ii, int> iii;
typedef vector<ii> vii;

const int N = 2e5 + 1;
const int MOD = 1e9 + 9;
const int INF = 2e9;
const int sq5 = 383008016;
const int X = 691504013;
const int Y = 308495997;
const int A = 276601605;

class Task446C {
public:
    int add(int x, int y) { return ((x + y) >= MOD ? x + y - MOD : x + y); }

    int sub(int x, int y) { return ((x - y) < 0 ? x - y + MOD : x - y); }

    int mul(int x, int y) { return (int) ((1LL * x * y) % MOD); }

    int pow(int x, ll p) {
        if (p == 0) return 1;
        int t = pow(x, p / 2);
        if ((p & 1) == 1)
            return mul(mul(t, t), x);
        return mul(t, t);
    }

    int inv(int x) { return pow(x, MOD - 2); }

    int div(int x, int y) { return mul(x, inv(y)); }

    int n, q;
    vi node;
    vii lazy;
    vi a;
    vi px, py, cx, cy;

    int cal(int x, int l) {
        return div(sub(pow(x, l), 1), x - 1);
    }

    void build(int i, int l, int r) {
        if (l == r) {
            node[i] = a[l];
            return;
        }
        int m = (l + r) >> 1;
        build(i * 2, l, m);
        build(i * 2 + 1, m + 1, r);
        node[i] = add(node[i * 2], node[i * 2 + 1]);
    }

    void lazyUpdate(int i, int l, int r) {
        if (lazy[i].F != 0) {
            int p = mul(lazy[i].F, cx[r - l + 1]);
            int s = mul(lazy[i].S, cy[r - l + 1]);
            node[i] = add(node[i], mul(A, sub(p, s)));
            if (l != r) {
                int m = (l + r) >> 1;
                lazy[i * 2].F = add(lazy[i * 2].F, lazy[i].F);
                lazy[i * 2].S = add(lazy[i * 2].S, lazy[i].S);
                lazy[i * 2 + 1].F = add(lazy[i * 2 + 1].F, mul(lazy[i].F, px[m + 1 - l]));
                lazy[i * 2 + 1].S = add(lazy[i * 2 + 1].S, mul(lazy[i].S, py[m + 1 - l]));
            }
            lazy[i].F = 0;
            lazy[i].S = 0;
        }
    }

    void update(int i, int l, int r, int tL, int tR) {
        lazyUpdate(i, l, r);
        if (l > r || l > tR || tL > r)return;
        if (tL <= l && r <= tR) {
            lazy[i].F = px[l - tL + 1];
            lazy[i].S = py[l - tL + 1];
            lazyUpdate(i, l, r);
            return;
        }
        int m = (l + r) >> 1;
        update(i * 2, l, m, tL, tR);
        update(i * 2 + 1, m + 1, r, tL, tR);
        node[i] = add(node[i * 2], node[i * 2 + 1]);
    }

    int get(int i, int l, int r, int tL, int tR) {
        lazyUpdate(i, l, r);
        if (l > r || l > tR || tL > r) return 0;
        if (tL <= l && r <= tR) return node[i];
        int m = (l + r) >> 1;
        return add(get(i * 2, l, m, tL, tR), get(i * 2 + 1, m + 1, r, tL, tR));
    }

    void build() {
        lazy.assign(4 * n, ii(0, 0));
        node.assign(4 * n, 0);
        build(1, 1, n);
        px.assign(n + 1, 1);
        py.assign(n + 1, 1);
        rf(i, 1, n) px[i] = mul(px[i - 1], X);
        rf(i, 1, n) py[i] = mul(py[i - 1], Y);
        cx.assign(n + 1, 1);
        cy.assign(n + 1, 1);
        rf(i, 1, n) cx[i] = cal(X, i);
        rf(i, 1, n) cy[i] = cal(Y, i);
    }

    void solve(istream &in, ostream &out) {
        in >> n >> q;
        a.pb(0);
        rf(i, 1, n) {
            int tmp;
            in >> tmp;
            a.pb(tmp);
        }
        build();

        while (q--) {
            int c, l, r;
            in >> c >> l >> r;
            if (c == 1)
                update(1, 1, n, l, r);
            else
                out << get(1, 1, n, l, r) << "\n";
        }
    }
};

class TestCase {
public:
    static constexpr int numTest = 0;
    static constexpr bool haveAns = false;

    static void generateTest(ostream &test) {
    }

    static void solve(istream &in, ostream &out) {
    }
};

class Checker {
public:
    static constexpr double arg = 0.0;

    static bool check(istream &in, istream &out) {
    }
};



int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    Task446C solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    out << fixed << setprecision(10);
    solver.solve(in, out);
    return 0;
}