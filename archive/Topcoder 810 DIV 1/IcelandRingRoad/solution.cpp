#include <bits/stdc++.h>

using namespace std;

struct segtree_radd_rsum {
  struct e {
    int cnt;
    int sum;
  };
  int n;
  vector<e> st;
  vector<int> lazy;
  vector<int> sum;
  segtree_radd_rsum(int _n, vector<int> &c) : n(_n), sum(_n) {
    st.assign(4 * n, {0, 0});
    lazy.assign(4 * n, {0});
    sum[0] = c[0];
    for (int i = 1; i < n; i++) {
      sum[i] = sum[i - 1] + c[i];
    }
  }
  void lazy_prop(int i, int l, int r) {
    if (lazy[i] != 0) {
      st[i].cnt += lazy[i];
      if (l != r) {
        lazy[i * 2 + 1] += lazy[i];
        lazy[i * 2 + 2] += lazy[i];
      }
      lazy[i] = 0;
      if (st[i].cnt == 0) {
        if (l != r) {
          int m = (l + r) / 2;
          st[i].sum = get_sum(l, m) + get_sum(m + 1, r);
        } else {
          st[i].sum = 0;
        }
      } else {
        st[i].sum = (l == 0) ? sum[r] : sum[r] - sum[l - 1];
      }
    }
  }
  void update(int i, int l, int r, int ql, int qr, int v) {
    lazy_prop(i, l, r);
    if (r < ql || qr < l) {
      return;
    }
    if (ql <= l && r <= qr) {
      lazy[i] += v;
      lazy_prop(i, l, r);
      return;
    }
    int m = (l + r) / 2;
    update(i * 2 + 1, l, m, ql, qr, v);
    update(i * 2 + 2, m + 1, r, ql, qr, v);
    st[i].sum = st[i * 2 + 1].sum + st[i * 2 + 2].sum;
  }
  int get_sum(int i, int l, int r, int ql, int qr) {
    lazy_prop(i, l, r);
    if (r < ql || qr < l || qr < ql) {
      return 0;
    }
    if (ql <= l && r <= qr) {
      return st[i].sum;
    }
    int m = (l + r) / 2;
    return get_sum(i * 2 + 1, l, m, ql, qr) + get_sum(i * 2 + 2, m + 1, r, ql, qr);
  }
  void add(int l, int r) {
    assert(l <= r && 0 <= l && r < n);
    update(0, 0, n - 1, l, r, 1);
  }
  void remove(int l, int r) {
    assert(l <= r && 0 <= l && r < n);
    update(0, 0, n - 1, l, r, -1);
  }
  int get_sum(int l, int r) {
    assert(l <= r && 0 <= l && r < n);
    return get_sum(0, 0, n - 1, l, r);
  }
};

class IcelandRingRoad {
public:
  int solve(int N, int P, int M, long long state) {
    vector<int> C(N);
    vector<int> L(P);
    vector<int> W(P);
    for (int i = 0; i < N; i++) {
      state = (state * 1103515245 + 12345) % (1LL << 31);
      C[i] = 1 + ((state / 10) % M);
    }
    vector<vector<int>> list(N, vector<int>());
    for (int j = 0; j < P; j++) {
      state = (state * 1103515245 + 12345) % (1LL << 31);
      L[j] = ((state / 10) % N);
      state = (state * 1103515245 + 12345) % (1LL << 31);
      W[j] = ((state / 10) % N);
      if (W[j] != L[j]) {
        list[min(W[j], L[j])].push_back(max(W[j], L[j]));
      }
    }
    for (int i = 0; i < N - 1; i++) {
      C.push_back(C[i]);
    }
    segtree_radd_rsum st((int)C.size(), C);
    for (int i = 0; i < P; i++) {
      if (W[i] != L[i]) {
        st.add(min(L[i], W[i]), max(L[i], W[i]) - 1);
      }
    }
    int ans = st.get_sum(0, 2 * N - 2);
    for (int i = 0; i < N - 1; i++) {
      for (int j : list[i]) {
        st.remove(i, j - 1);
        if (j < N) {
          st.add(j, i + N - 1);
          list[j].push_back(i + N);
        } else {
          st.add(j, i + N - 1);
        }
      }
      ans = min(ans, st.get_sum(0, 2 * N - 2));
    }
    return ans;
  }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, long long p3, bool hasAnswer, int p4) {
  cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2 << "," << p3;
  cout << "]" << endl;
  IcelandRingRoad *obj;
  int answer;
  obj = new IcelandRingRoad();
  clock_t startTime = clock();
  answer = obj->solve(p0, p1, p2, p3);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << p4 << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << answer << endl;
  if (hasAnswer) {
    res = answer == p4;
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  } else if (hasAnswer) {
    cout << "Match :-)" << endl;
  } else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}
int main() {
  bool all_right;
  all_right = true;

  int p0;
  int p1;
  int p2;
  long long p3;
  int p4;

  {
    // ----- test 0 -----
    p0 = 10;
    p1 = 2;
    p2 = 1000;
    p3 = 474747ll;
    p4 = 1161;
    all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
    // ------------------
  }

  {
    // ----- test 1 -----
    p0 = 3;
    p1 = 47;
    p2 = 1000;
    p3 = 420042ll;
    p4 = 991;
    all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
    // ------------------
  }

  {
    // ----- test 2 -----
    p0 = 100;
    p1 = 12;
    p2 = 1;
    p3 = 12345ll;
    p4 = 83;
    all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
    // ------------------
  }

  {
    // ----- test 1 -----
    p0 = 3;
    p1 = 5;
    p2 = 1000;
    p3 = 420042ll;
    p4 = 991;
    all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, false, p4) && all_right;
    // ------------------
  }

  {
    // ----- test 1 -----
    p0 = 500000;
    p1 = 100000;
    p2 = 1000;
    p3 = 474447;
    p4 = 249891233;
    all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
    // ------------------
  }

  {
    // ----- test 1 -----
    p0 = 499997;
    p1 = 99997;
    p2 = 997;
    p3 = 2352366;
    p4 = 249270130;
    all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
    // ------------------
  }

  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  } else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// END KAWIGIEDIT TESTING
